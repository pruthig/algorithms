Closest pair algorithm:

For 1-D - Sort the points according to the 1-Dimension and pick the smallest between the 2 values in the order.

ClosestPair of a set of points:
1. Divide the set into two equal sized parts by the line l, and recursively compute the minimal distance in each part.
2. Let d be the minimal of the two minimal distances.
3. Eliminate points that lie farther than d apart from l
4. Sort the remaining points according to their y-coordinates
5. Scan the remaining points in the y order and compute the distances of each point to its five neighbors.
6. If any of these distances is less than d then update d.

Steps 2-6 define the merging process which must be repeated logn times because this is a divide and conquer algortithm:
Step 2 takes O(1) time
Step 3 takes O(n) time
Step 4 is a sort that takes O(nlogn) time
Step 5 takes O(n) time (as we saw in the previous section)
Step 6 takes O(1) time

Master theorem:
Used to determine running time of recursive algorithms.
Defined as:

T(n) = a * T( n / b ) + O( n^d )  where
a -> Number of recursive calls
b -> Factor by which input problem is divided, e.g for merge sort it is 2
d -> Denotes the effort put while combining the solution.

a = b^d  ==>  O( (n^d)*logn )
b^d > a  ==>  O( n^d )
a > b^d  ==>  O( n^(logb^a) )

Effort put in recursion = c*n^d * ( (j = 0 to logb ) Î£ ( (a / b^d )^j )


Quicksort Algorithm:
> Elegant and in place
> Practical with O(nlogn) time

Steps:
Choose a pivot
Run a loop so that all elements < pivot are to the left of the pivot and rest to the right
Quicksort runs in O(n^2) if sorted array is passed because only 1st half will be executed since 2 halfs are not divided evenly.
or we can call it as unbalanced split.
== Random Pivot ==
